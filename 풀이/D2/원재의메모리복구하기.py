T = int(input())

for tc in range(1, T+1):
    # 문자열 or 리스트 둘중에 뭘 써야 할까??
    # "string" or ["s" , "t" , "r" , "i" , "n" , "g" ]
    # 문자열 => str type => 불변
    # 리스트 => list type => 가변
    # 내가 i 번째 글자를 바꾸려고 하면?
    # str 타입은 불가능
    # list 타입은 가능
    origin = list(input()) # 원래 메모리 비트

    # 길이는 따로 변수에 저장해두는게 좋다.
    n = len(origin)

    # 앞에서 차례로 바꿀 메모리
    mem = ["0"] * n
    
    # 초기 상태가 00000... 인 메모리를 바꿔서 원래 상태인 001100.. 이런상태로 바꾸기 까지
    # 바꾼 비트의 개수
    cnt = 0

    # 맨 앞부터 비트를 바꿔 본다 0 또는 1로
    # 0 또는 1로 바꾸면 그 뒤에있는 비트도 똑같이 다 바꿔준다.
    for i in range(n):
        # 바꾸기 전에 i번째 비트가 같다면?? 굳이 바꿀 필요가 있을까??
        ith_char = origin[i]
        # 원래 메모리의 i번째 글자와 현재 내가 바꾸고 있는 메모리의 i번째 글자가 다르면 바꾼다.
        if ith_char != mem[i]:
            # i 번째 비트를 바꿨다?? => i+1 번째 비트부터 n-1 번째 비트까지 다 바꿔줘야한다.
            # i번째 비트를 바꿀때마다 cnt 를 1씩 증가
            cnt += 1
            for j in range(i, n):
                # 반복문을 하나 더 사용 i <= j < n 일때 j 번째 글자도 모두 변경한다.
                # j번째 비트 (i부터 n-1 까지 다 바꾸는 게 끝났으면 원래 비트와 비교)
                mem[j] = ith_char

        if mem == origin:
            # 비교했는데 비트가 같다??? (문자열의 모양이) 뒤에는 볼 필요가 없다.
            # 반복문을 중단하고 지금까지 계산한 cnt를 정답으로 출력
            break

            # 파이썬은 리스트 비교도 가능
            # ["1" , "1" , "1" ] == ["1" , "1" , "1" ] 의 결과는 True
            # ["1" , "0" , "1" ] == ["1" , "1" , "1" ] 의 결과는 False

    print(f"#{tc} {cnt}")